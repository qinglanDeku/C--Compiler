编译原理阶段四设计：
	按需求分析：
	一：代码分块
	 需要类：
		1、代码块：成员变量的设置基于线性中间代码，中间代码使用list存放，为了分块需要
设置位置标识符进行分块，使用vector，依次存放代码块的起始行和终止行。（前一个的终止是后一个
的起始，第一个基本块从0开始，最后一个基本块在最后一行结束）。能够访问到中间代码的每一行。
		于是有基本数据成员：
	private：
		int begin, end;
		list<*interCode>::iterator BP, EP;
	public：
		BasicBlock(list<*interCode>::iterator BP, list<*interCode>::iterator EP);
		string getOneLine();		//获得某行中间代码
		int getBegin();			//获得中间代码的起始行号；
		int getEnd();			//获得中间代码的结束行号；
		int getSize();			//获得基本块中间代码的行数；
		InterCode::IRtype getCodeType();	//获得中间代码的type	
		string getOperand(int i);		//获得代码中的第i个操作数，如果没有返回空字符串。
		string getOperator();		//获得中间代码右侧的操作符， 如果没有返回空字符串。
		......


		2、代码块表：代码块基本数据组成的表，使用list存放基本块。先考虑以函数体划分代码块，
        对函数体内的每个数据都要在栈中为其开辟新空间，是的，虽然前阶段都当作全局变量处理，
        但是放在栈上更有利于函数的调用。
        在递归调用的时候需要考虑将已有的状态（寄存器中的数值压栈)
	private：	
		vector<BasicBlock> blockList;
	public:
		BlockList(list<*interCode> codeList);	//构造函数，划分基本块。需要用到中间代码表和代码块的构造函数
		~BlockList;
		const basicBlock& getBlock(int i);	//得到第i个基本块，从0开始。


	
		3、寄存器表：32个寄存器，除了几个特殊的寄存器之外，剩余的寄存器用来分配运算需要的
变量。这样的话需要两个类：一个寄存器，一个寄存器表
		class reg：需要实现的功能：
			1、设置寄存器的占用状态，并且自己寄存器有自己的名字。
			2、同时记录寄存器内寄存的变量，用于溢出（需要考虑数组类型？)
			3、寄存器的基本功能：存放数据（无论是数值还是地址），并且能获得其中的数据。
			具替的执行过程大概是，取出指定变量的地址（到寄存器），再由此取出地址
			从这个地址中拿出变量的数值到某个寄存器（这个寄存器描述符记下对应变量的地址？）
		
		class reg：将32个寄存器放在一起组织，即可用名字标识也可以用编号标识。
			1、能够获取指定寄存器的引用或指针（通过名字或指针）
			2、管理，分配，回收空闲的寄存器：外界请求分配寄存器时，检查是否有空闲
寄存器，有的话直接返回其引用，没有的话按照启发策略选择一个被占用的寄存器，清空它并返回其引用。
可以使用一个空闲寄存器队列，和已被使用寄存器队列（这个队列可以将每次刚使用一次的寄存器放在队列最后，
于是最不经常备用的寄存器就会被放在队列的后面，可以用stl中的deque）。

		4、翻译类：能够管理寄存器组，掌控代码块表，并且由此能够生成机器代码。
        class Variable  变量类，进行汇编翻译过程中用来管理变量存放，需要实现的功能：
            1、变量存储的位置。
            2、变量大小和名字。
            3、每一个和Vriable和一个VariableOP相对应。

        class VariableList 变量表，组织Variable。要实现的功能：
            1、管理每个Variable对象。
            2、能够提供指定的变量。
		class Asselbly 要实现的功能：
			1、能够使用寄存器组，并且初始寄存器组。能够管理栈空间（用两个int指明栈顶和当前栈底
和寄存器配合）
			2、将掌控的所有代码块翻译成汇编代码(mips), 汇编代码考虑用vector存储。
有一套翻译方案。
			3、能够输出汇编代码到文件中。
		

			
		
			